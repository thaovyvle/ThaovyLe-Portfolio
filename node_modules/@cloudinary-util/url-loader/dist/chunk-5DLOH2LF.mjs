var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/constants/qualifiers.ts
import { z as z2 } from "zod";
import { testColorIsHex, convertColorHexToRgb } from "@cloudinary-util/util";

// src/constants/parameters.ts
var parameters_exports = {};
__export(parameters_exports, {
  angle: () => angle,
  aspectRatio: () => aspectRatio,
  aspectRatioModesEnum: () => aspectRatioModesEnum,
  crop: () => crop,
  cropModesEnum: () => cropModesEnum,
  flags: () => flags,
  flagsEnum: () => flagsEnum,
  format: () => format,
  gravity: () => gravity,
  height: () => height,
  width: () => width,
  x: () => x,
  y: () => y,
  zoom: () => zoom
});
import { z } from "zod";
var cropModesEnum = z.enum([
  "auto",
  "fill",
  "lfill",
  "fill_pad",
  "crop",
  "thumb",
  "scale",
  "fit",
  "limit",
  "mfit",
  "pad",
  "lpad",
  "mpad",
  "imagga_scale",
  "imagga_crop"
]);
var flagsEnum = z.enum([
  "animated",
  "any_format",
  "apng",
  "attachment",
  "awebp",
  "clip",
  "clip_evenodd",
  "cutter",
  "force_icc",
  "force_strip",
  "getinfo",
  "group4",
  "hlsv3",
  "ignore_aspect_ratio",
  "ignore_mask_channels",
  "immutable_cache",
  "keep_attribution",
  "keep_dar",
  "keep_iptc",
  "layer_apply",
  "lossy",
  "mono",
  "no_overflow",
  "no_stream",
  "png8_fl_png24_fl_png32",
  "preserve_transparency",
  "progressive",
  "rasterize",
  "region_relative",
  "relative",
  "replace_image",
  "sanitize",
  "splice",
  "streaming_attachment",
  "strip_profile",
  "text_disallow_overflow",
  "text_no_trim",
  "tiff8_lzw",
  "tiled",
  "truncate_ts",
  "waveform"
]);
var angle = {
  qualifier: "a",
  schema: z.union([
    z.string(),
    z.number()
  ]).describe(JSON.stringify({
    text: "Rotates or flips an asset by the specified number of degrees or automatically according to its orientation or available metadata.",
    url: "https://cloudinary.com/documentation/transformation_reference#a_angle"
  }))
};
var aspectRatioModesEnum = z.enum([
  "vflip",
  "hflip",
  "ignore",
  "auto_right",
  "auto_left"
]);
var aspectRatioSchema = z.union([
  z.number(),
  aspectRatioModesEnum,
  z.string()
]);
var aspectRatio = {
  qualifier: "ar",
  schema: aspectRatioSchema.describe(JSON.stringify({
    text: "Crops or resizes the asset to a new aspect ratio.",
    url: "https://cloudinary.com/documentation/transformation_reference#ar_aspect_ratio"
  }))
};
var cropSchema = cropModesEnum;
var crop = {
  qualifier: "c",
  schema: cropSchema.describe(JSON.stringify({
    text: "Mode to use when cropping an asset.",
    url: "https://cloudinary.com/documentation/transformation_reference#c_crop_resize"
  }))
};
var flags = {
  qualifier: "fl",
  schema: z.union([
    flagsEnum,
    z.array(flagsEnum)
  ]).describe(JSON.stringify({
    text: "Alters the regular behavior of another transformation or the overall delivery behavior.",
    url: "https://cloudinary.com/documentation/transformation_reference#fl_flag"
  }))
};
var format = {
  qualifier: "f",
  // @TODO: enum
  schema: z.string().describe(JSON.stringify({
    text: "Converts (if necessary) and delivers an asset in the specified format regardless of the file extension used in the delivery URL.",
    url: "https://cloudinary.com/documentation/transformation_reference#f_format"
  }))
};
var gravitySchema = z.string();
var gravity = {
  qualifier: "g",
  schema: gravitySchema.describe(JSON.stringify({
    text: "Determines which part of an asset to focus on. Note: Default of auto is applied for supported crop modes only.",
    url: "https://cloudinary.com/documentation/transformation_reference#g_gravity"
  }))
};
var heightSchema = z.union([
  z.number(),
  z.string()
]);
var height = {
  qualifier: "h",
  schema: heightSchema.describe(JSON.stringify({
    text: "A qualifier that determines the height of a transformed asset or an overlay.",
    url: "https://cloudinary.com/documentation/transformation_reference#h_height"
  }))
};
var widthSchema = z.union([
  z.number(),
  z.string()
]);
var width = {
  qualifier: "w",
  schema: widthSchema.describe(JSON.stringify({
    text: "A qualifier that sets the desired width of an asset using a specified value, or automatically based on the available width.",
    url: "https://cloudinary.com/documentation/transformation_reference#w_width"
  }))
};
var x = {
  qualifier: "x",
  schema: z.union([
    z.string(),
    z.number()
  ]).describe(JSON.stringify({
    text: "Adjusts the starting location or offset of the x axis.",
    url: "https://cloudinary.com/documentation/transformation_reference#x_y_coordinates"
  }))
};
var y = {
  qualifier: "y",
  schema: z.union([
    z.string(),
    z.number()
  ]).describe(JSON.stringify({
    text: "Adjusts the starting location or offset of the y axis.",
    url: "https://cloudinary.com/documentation/transformation_reference#x_y_coordinates"
  }))
};
var zoomSchema = z.string();
var zoom = {
  schema: zoomSchema.describe(JSON.stringify({
    text: "Controls how close to crop to the detected coordinates when using face-detection, custom-coordinate, or object-specific gravity.",
    url: "https://cloudinary.com/documentation/transformation_reference#z_zoom"
  }))
};

// src/constants/qualifiers.ts
var convertersColors = [
  {
    test: testColorIsHex,
    convert: convertColorHexToRgb
  }
];
var primary = {
  aspectRatio,
  crop,
  gravity,
  height,
  width
};
var position = {
  angle,
  gravity,
  x,
  y
};
var text = {
  alignment: {
    qualifier: false,
    order: 6
  },
  antialias: {
    qualifier: "antialias"
  },
  border: {
    qualifier: "bo",
    location: "primary"
  },
  color: {
    qualifier: "co",
    location: "primary",
    converters: convertersColors
  },
  fontFamily: {
    qualifier: false,
    order: 1
  },
  fontSize: {
    qualifier: false,
    order: 2
  },
  fontStyle: {
    qualifier: false,
    order: 4
  },
  fontWeight: {
    qualifier: false,
    order: 3
  },
  hinting: {
    qualifier: "hinting"
  },
  letterSpacing: {
    qualifier: "letter_spacing"
  },
  lineSpacing: {
    qualifier: "line_spacing"
  },
  stroke: {
    qualifier: "self",
    order: 7
  },
  textDecoration: {
    qualifier: false,
    order: 5
  }
};
var effects = {
  angle,
  art: {
    prefix: "e",
    qualifier: "art",
    schema: z2.string().describe(JSON.stringify({
      text: "Applies the selected artistic filter.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_art"
    }))
  },
  autoBrightness: {
    prefix: "e",
    qualifier: "auto_brightness",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Automatically adjusts the image brightness and blends the result with the original image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_auto_brightness"
    }))
  },
  autoColor: {
    prefix: "e",
    qualifier: "auto_color",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Automatically adjusts the image color balance and blends the result with the original image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_auto_color"
    }))
  },
  autoContrast: {
    prefix: "e",
    qualifier: "auto_contrast",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Automatically adjusts the image contrast and blends the result with the original image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_auto_contrast"
    }))
  },
  assistColorblind: {
    prefix: "e",
    qualifier: "assist_colorblind",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Applies stripes or color adjustment to help people with common color blind conditions to differentiate between colors that are similar for them.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_assist_colorblind"
    }))
  },
  background: {
    qualifier: "b",
    schema: z2.string().describe(JSON.stringify({
      text: "Applies a background to empty or transparent areas.",
      url: "https://cloudinary.com/documentation/transformation_reference#b_background"
    }))
  },
  blackwhite: {
    prefix: "e",
    qualifier: "blackwhite",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Converts an image to black and white.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_blackwhite"
    }))
  },
  blur: {
    prefix: "e",
    qualifier: "blur",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a blurring filter to an asset.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_blur"
    }))
  },
  blurFaces: {
    prefix: "e",
    qualifier: "blur_faces",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Blurs all detected faces in an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_blur_faces"
    }))
  },
  blurRegion: {
    prefix: "e",
    qualifier: "blur_region",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a blurring filter to the region of an image specified by x, y, width and height, or an area of text. If no region is specified, the whole image is blurred.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_blur_region"
    }))
  },
  border: {
    qualifier: "bo",
    schema: z2.string().describe(JSON.stringify({
      text: "Adds a solid border around an image or video.",
      url: "https://cloudinary.com/documentation/transformation_reference#bo_border"
    }))
  },
  brightness: {
    prefix: "e",
    qualifier: "brightness",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts the image or video brightness.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_brightness"
    }))
  },
  brightnessHSB: {
    prefix: "e",
    qualifier: "brightness_hsb",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts image brightness modulation in HSB to prevent artifacts in some images.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_brightness_hsb"
    }))
  },
  cartoonify: {
    prefix: "e",
    qualifier: "cartoonify",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a cartoon effect to an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_cartoonify"
    }))
  },
  color: {
    qualifier: "co",
    schema: z2.string().describe(JSON.stringify({
      text: "A qualifier that specifies the color to use with the corresponding transformation.",
      url: "https://cloudinary.com/documentation/transformation_reference#co_color"
    })),
    converters: convertersColors
  },
  colorize: {
    prefix: "e",
    qualifier: "colorize",
    schema: z2.string().describe(JSON.stringify({
      text: "Colorizes an image. By default, gray is used for colorization. You can specify a different color using the color qualifier.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_colorize"
    }))
  },
  contrast: {
    prefix: "e",
    qualifier: "contrast",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts an image or video contrast.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_contrast"
    }))
  },
  displace: {
    prefix: "e",
    qualifier: "distort",
    schema: z2.string().describe(JSON.stringify({
      text: "Displaces the pixels in an image according to the color channels of the pixels in another specified image (a gradient map specified with the overlay parameter).",
      url: "https://cloudinary.com/documentation/transformation_reference#e_displace"
    }))
  },
  distort: {
    prefix: "e",
    qualifier: "distort",
    schema: z2.string().describe(JSON.stringify({
      text: "Distorts an image to a new shape by either adjusting its corners or by warping it into an arc.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_distort"
    }))
  },
  fillLight: {
    prefix: "e",
    qualifier: "fill_light",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts the fill light and optionally blends the result with the original image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_fill_light"
    }))
  },
  gamma: {
    prefix: "e",
    qualifier: "gamma",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts the image or video gamma level.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_gamma"
    }))
  },
  gradientFade: {
    prefix: "e",
    qualifier: "gradient_fade",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a gradient fade effect from the edge of an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_gradient_fade"
    }))
  },
  grayscale: {
    prefix: "e",
    qualifier: "grayscale",
    schema: z2.boolean().describe(JSON.stringify({
      text: "Converts an image to grayscale (multiple shades of gray).",
      url: "https://cloudinary.com/documentation/transformation_reference#e_grayscale"
    }))
  },
  hue: {
    prefix: "e",
    qualifier: "hue",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts an image's hue.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_hue"
    }))
  },
  improve: {
    prefix: "e",
    qualifier: "improve",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts an image's colors, contrast and brightness to improve its appearance.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_improve"
    }))
  },
  loop: {
    prefix: "e",
    qualifier: "loop",
    schema: z2.union([
      z2.boolean(),
      z2.number(),
      z2.string()
    ]).describe(JSON.stringify({
      text: "Loops a video or animated image the specified number of times.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_loop"
    }))
  },
  multiply: {
    prefix: "e",
    qualifier: "multiply",
    schema: z2.boolean().describe(JSON.stringify({
      text: "A qualifier that blends image layers using the multiply blend mode",
      url: "https://cloudinary.com/documentation/transformation_reference#e_multiply"
    }))
  },
  negate: {
    prefix: "e",
    qualifier: "negate",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "https://cloudinary.com/documentation/transformation_reference#e_negate",
      url: "https://cloudinary.com/documentation/transformation_reference#e_negate"
    }))
  },
  noise: {
    prefix: "e",
    qualifier: "noise",
    schema: z2.boolean().describe(JSON.stringify({
      text: "https://cloudinary.com/documentation/transformation_reference#e_noise",
      url: "https://cloudinary.com/documentation/transformation_reference#e_noise"
    }))
  },
  oilPaint: {
    prefix: "e",
    qualifier: "oil_paint",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "https://cloudinary.com/documentation/transformation_reference#e_oil_paint",
      url: "https://cloudinary.com/documentation/transformation_reference#e_oil_paint"
    }))
  },
  opacity: {
    qualifier: "o",
    schema: z2.union([
      z2.string(),
      z2.number()
    ]).describe(JSON.stringify({
      text: "Adjusts the opacity of an asset and makes it semi-transparent.",
      url: "https://cloudinary.com/documentation/transformation_reference#o_opacity"
    }))
  },
  outline: {
    prefix: "e",
    qualifier: "outline",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Adds an outline effect to an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_outline"
    }))
  },
  pixelate: {
    prefix: "e",
    qualifier: "pixelate",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a pixelation effect.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_pixelate"
    }))
  },
  pixelateFaces: {
    prefix: "e",
    qualifier: "pixelate_faces",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Pixelates all detected faces in an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_pixelate_faces"
    }))
  },
  pixelateRegion: {
    prefix: "e",
    qualifier: "pixelate_region",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Pixelates the region of an image specified by x, y, width and height, or an area of text.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_pixelate_region"
    }))
  },
  radius: {
    qualifier: "r",
    schema: z2.string().describe(JSON.stringify({
      text: "Rounds the corners of an image or video.",
      url: "https://cloudinary.com/documentation/transformation_reference#r_round_corners"
    }))
  },
  redeye: {
    prefix: "e",
    qualifier: "redeye",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Automatically removes red eyes in an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_redeye"
    }))
  },
  replaceColor: {
    prefix: "e",
    qualifier: "replace_color",
    schema: z2.string().describe(JSON.stringify({
      text: "Maps an input color and those similar to the input color to corresponding shades of a specified output color.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_replace_color"
    }))
  },
  saturation: {
    prefix: "e",
    qualifier: "saturation",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Adjusts an image or video saturation level.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_saturation"
    }))
  },
  screen: {
    prefix: "e",
    qualifier: "screen",
    schema: z2.boolean().describe(JSON.stringify({
      text: "A qualifier that blends image layers using the screen blend mode.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_screen"
    }))
  },
  sepia: {
    prefix: "e",
    qualifier: "sepia",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Changes the color scheme of an image to sepia.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_sepia"
    }))
  },
  shadow: {
    prefix: "e",
    qualifier: "shadow",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Adds a gray shadow to the bottom right of an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_shadow"
    }))
  },
  sharpen: {
    prefix: "e",
    qualifier: "sharpen",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a sharpening filter.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_sharpen"
    }))
  },
  shear: {
    prefix: "e",
    qualifier: "shear",
    schema: z2.string().describe(JSON.stringify({
      text: "Skews an image according to the two specified values in degrees.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_shear"
    }))
  },
  simulateColorblind: {
    prefix: "e",
    qualifier: "simulate_colorblind",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Simulates the way an image would appear to someone with the specified color blind condition.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_simulate_colorblind"
    }))
  },
  tint: {
    prefix: "e",
    qualifier: "tint",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Blends an image with one or more tint colors at a specified intensity.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_tint"
    }))
  },
  trim: {
    prefix: "e",
    qualifier: "trim",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Detects and removes image edges whose color is similar to the corner pixels.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_trim"
    }))
  },
  unsharpMask: {
    prefix: "e",
    qualifier: "unsharp_mask",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Applies an unsharp mask filter to an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_unsharp_mask"
    }))
  },
  vectorize: {
    prefix: "e",
    qualifier: "vectorize",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Vectorizes an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_vectorize"
    }))
  },
  vibrance: {
    prefix: "e",
    qualifier: "vibrance",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a vibrance filter to an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_vibrance"
    }))
  },
  vignette: {
    prefix: "e",
    qualifier: "vignette",
    schema: z2.union([
      z2.string(),
      z2.boolean()
    ]).describe(JSON.stringify({
      text: "Applies a vignette effect to an image.",
      url: "https://cloudinary.com/documentation/transformation_reference#e_vignette"
    }))
  }
};

// src/types/asset.ts
import { z as z13 } from "zod";

// src/plugins/cropping.ts
var cropping_exports = {};
__export(cropping_exports, {
  assetTypes: () => assetTypes,
  plugin: () => plugin,
  props: () => props
});
import { z as z3 } from "zod";

// src/lib/transformations.ts
function constructTransformation({ prefix, qualifier, value, converters }) {
  let transformation = "";
  if (prefix) {
    transformation = `${prefix}_`;
  }
  let transformationValue = value;
  converters?.forEach(({ test, convert }) => {
    if (!test(transformationValue))
      return;
    transformationValue = convert(transformationValue);
  });
  if (transformationValue === true || transformationValue === "true") {
    return `${transformation}${qualifier}`;
  }
  if (typeof transformationValue === "string" || typeof transformationValue === "number") {
    if (prefix) {
      return `${transformation}${qualifier}:${transformationValue}`;
    } else {
      return `${qualifier}_${transformationValue}`;
    }
  }
}
function promptArrayToString(promptArray) {
  return `(${promptArray.join(";")})`;
}
function normalizeNumberParameter(param) {
  if (typeof param !== "string")
    return param;
  return parseInt(param);
}

// src/plugins/cropping.ts
var cropsAspectRatio = ["auto", "crop", "fill", "lfill", "fill_pad", "thumb"];
var cropsGravityAuto = ["auto", "crop", "fill", "lfill", "fill_pad", "thumb"];
var cropsWithZoom = ["crop", "thumb"];
var DEFAULT_CROP = "limit";
var cropOptionsSchema = z3.object({
  aspectRatio: aspectRatio.schema.optional(),
  type: crop.schema,
  gravity: gravity.schema.optional(),
  height: height.schema.optional(),
  width: width.schema.optional(),
  zoom: zoom.schema.optional(),
  source: z3.boolean().optional()
});
var props = {
  aspectRatio: aspectRatio.schema.optional(),
  crop: z3.union([
    crop.schema,
    cropOptionsSchema,
    z3.array(cropOptionsSchema)
  ]).default(DEFAULT_CROP).optional(),
  gravity: gravity.schema.optional(),
  zoom: zoom.schema.optional()
};
var assetTypes = ["image", "images", "video", "videos"];
function plugin(props21) {
  const { cldAsset, options } = props21;
  let crops = [];
  if (typeof options.crop === "string" || typeof options.crop === "undefined") {
    crops.push({
      aspectRatio: options.aspectRatio,
      width: options.width,
      height: options.height,
      gravity: options.gravity,
      type: options.crop || DEFAULT_CROP,
      zoom: options.zoom
    });
  } else if (typeof options.crop === "object" && !Array.isArray(options.crop)) {
    crops.push(options.crop);
  } else if (Array.isArray(options.crop)) {
    crops = options.crop;
  }
  if (crops.length === 1 && crops[0].source === true) {
    crops.push({
      aspectRatio: options.aspectRatio,
      width: options.width,
      height: options.height,
      gravity: options.gravity,
      type: DEFAULT_CROP,
      zoom: options.zoom
    });
  }
  let finalTransformations = [];
  let sourceTransformations = [];
  for (const crop2 of crops) {
    const cropDimensions = {
      width: crop2.width,
      height: crop2.height
    };
    if (typeof cropDimensions.width === "undefined" && typeof crop2.aspectRatio === "undefined") {
      cropDimensions.width = options.width;
      if (typeof cropDimensions.height === "undefined") {
        cropDimensions.height = options.height;
      }
    }
    const transformations = collectTransformations({
      aspectRatio: crop2.aspectRatio,
      gravity: crop2.gravity,
      type: crop2.type || DEFAULT_CROP,
      zoom: crop2.zoom,
      ...cropDimensions
    });
    if (transformations.length > 0) {
      if (crop2.source === true) {
        sourceTransformations.push(transformations);
      } else {
        finalTransformations.push(transformations);
      }
    }
  }
  sourceTransformations.forEach((transformation) => {
    if (transformation.length > 0) {
      cldAsset.addTransformation(transformation.join(","));
    }
  });
  const results = {
    options: {}
  };
  if (results.options && finalTransformations.length > 0) {
    results.options.resize = finalTransformations.map((transformation) => transformation.join(",")).join("/");
  }
  return results;
}
function collectTransformations(collectOptions) {
  const { aspectRatio: aspectRatio2, type: crop2, zoom: zoom2 } = collectOptions;
  let gravity2 = collectOptions.gravity;
  let height2 = normalizeNumberParameter(collectOptions.height);
  let width2 = normalizeNumberParameter(collectOptions.width);
  const transformations = [];
  const hasDefinedDimensions = height2 || width2;
  const hasValidAspectRatio = aspectRatio2 && cropsAspectRatio.includes(crop2);
  if (crop2 && (hasDefinedDimensions || hasValidAspectRatio)) {
    transformations.push(`c_${crop2}`);
  }
  if (hasValidAspectRatio) {
    transformations.push(`ar_${aspectRatio2}`);
  }
  if (width2) {
    transformations.push(`w_${width2}`);
  }
  if (!["limit"].includes(crop2) && typeof height2 === "number") {
    transformations.push(`h_${height2}`);
  }
  if (!gravity2 && cropsGravityAuto.includes(crop2)) {
    gravity2 = "auto";
  }
  if (gravity2) {
    if (gravity2 === "auto" && !cropsGravityAuto.includes(crop2)) {
      console.warn(`Auto gravity can only be used with crop modes: ${cropsGravityAuto.join(", ")}. Not applying gravity.`);
    } else {
      transformations.push(`g_${gravity2}`);
    }
  }
  if (zoom2) {
    if (zoom2 === "auto" && !cropsWithZoom.includes(crop2)) {
      console.warn(`Zoom can only be used with crop modes: ${cropsWithZoom.join(", ")}. Not applying zoom.`);
    } else {
      transformations.push(`z_${zoom2}`);
    }
  }
  return transformations;
}

// src/plugins/effects.ts
var effects_exports = {};
__export(effects_exports, {
  assetTypes: () => assetTypes2,
  plugin: () => plugin2,
  props: () => props2
});
import { z as z4 } from "zod";
var effectProps = {
  angle: effects.angle.schema.optional(),
  art: effects.art.schema.optional(),
  autoBrightness: effects.autoBrightness.schema.optional(),
  autoColor: effects.autoColor.schema.optional(),
  autoContrast: effects.autoContrast.schema.optional(),
  assistColorblind: effects.assistColorblind.schema.optional(),
  background: effects.background.schema.optional(),
  blackwhite: effects.blackwhite.schema.optional(),
  blur: effects.blur.schema.optional(),
  blurFaces: effects.blurFaces.schema.optional(),
  blurRegion: effects.blurRegion.schema.optional(),
  border: effects.border.schema.optional(),
  brightness: effects.brightness.schema.optional(),
  brightnessHSB: effects.brightnessHSB.schema.optional(),
  cartoonify: effects.cartoonify.schema.optional(),
  color: effects.color.schema.optional(),
  colorize: effects.colorize.schema.optional(),
  contrast: effects.contrast.schema.optional(),
  distort: effects.distort.schema.optional(),
  fillLight: effects.fillLight.schema.optional(),
  gamma: effects.gamma.schema.optional(),
  gradientFade: effects.gradientFade.schema.optional(),
  grayscale: effects.grayscale.schema.optional(),
  improve: effects.improve.schema.optional(),
  loop: effects.loop.schema.optional(),
  multiply: effects.multiply.schema.optional(),
  negate: effects.negate.schema.optional(),
  oilPaint: effects.oilPaint.schema.optional(),
  opacity: effects.opacity.schema.optional(),
  outline: effects.outline.schema.optional(),
  pixelate: effects.pixelate.schema.optional(),
  pixelateFaces: effects.pixelateFaces.schema.optional(),
  pixelateRegion: effects.pixelateRegion.schema.optional(),
  radius: effects.radius.schema.optional(),
  redeye: effects.redeye.schema.optional(),
  replaceColor: effects.replaceColor.schema.optional(),
  saturation: effects.saturation.schema.optional(),
  screen: effects.screen.schema.optional(),
  sepia: effects.sepia.schema.optional(),
  shadow: effects.shadow.schema.optional(),
  sharpen: effects.sharpen.schema.optional(),
  shear: effects.shear.schema.optional(),
  simulateColorblind: effects.simulateColorblind.schema.optional(),
  tint: effects.tint.schema.optional(),
  trim: effects.trim.schema.optional(),
  unsharpMask: effects.unsharpMask.schema.optional(),
  vectorize: effects.vectorize.schema.optional(),
  vibrance: effects.vibrance.schema.optional(),
  vignette: effects.vignette.schema.optional()
};
var props2 = {
  effects: z4.array(z4.object(effectProps)).describe(JSON.stringify({
    text: "Array of objects specifying transformations to be applied to asset."
  })).optional(),
  ...effectProps
};
var assetTypes2 = ["image", "images", "video", "videos"];
function plugin2(props21) {
  const { cldAsset, options } = props21;
  const transformationStrings = constructTransformationString({
    effects,
    options
  });
  transformationStrings.filter((t) => !!t).forEach((transformation) => cldAsset.effect(transformation));
  ;
  if (Array.isArray(options?.effects)) {
    options?.effects.forEach((effectsSet) => {
      const transformationString = constructTransformationString({
        effects,
        options: effectsSet
      }).filter((t) => !!t).join(",");
      cldAsset.effect(transformationString);
    });
  }
  function constructTransformationString({ effects: effects2, options: options2 }) {
    return Object.keys(effects2).map((key) => {
      const { prefix, qualifier, converters } = effects2[key];
      return constructTransformation({
        qualifier,
        prefix,
        value: options2?.[key],
        converters
      });
    });
  }
  return {};
}

// src/plugins/flags.ts
var flags_exports = {};
__export(flags_exports, {
  assetTypes: () => assetTypes3,
  plugin: () => plugin3,
  props: () => props3
});
var { flagsEnum: flagsEnum2 } = parameters_exports;
var props3 = {
  flags: flags.schema.optional()
};
var assetTypes3 = ["image", "images", "video", "videos"];
function plugin3(props21) {
  const { cldAsset, options } = props21;
  const { flags: flags2 = [] } = options;
  if (Array.isArray(flags2) && flags2.length > 0) {
    flags2.forEach((flag) => {
      const { success } = flagsEnum2.safeParse(flag);
      if (!success) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`Invalid flag ${flag}, not applying.`);
        }
        return;
      }
      cldAsset.addFlag(flag);
    });
  } else if (typeof flags2 === "object") {
    Object.entries(flags2).forEach(([qualifier, value]) => {
      const { success } = flagsEnum2.safeParse(qualifier);
      if (!success) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`Invalid flag ${qualifier}, not applying.`);
        }
        return;
      }
      cldAsset.addTransformation(`fl_${qualifier}:${value}`);
    });
  }
  return {};
}

// src/plugins/named-transformations.ts
var named_transformations_exports = {};
__export(named_transformations_exports, {
  assetTypes: () => assetTypes4,
  plugin: () => plugin4,
  props: () => props4,
  strict: () => strict
});
import { z as z5 } from "zod";
var NamedTransformationSchema = z5.string();
var props4 = {
  namedTransformations: z5.union([
    NamedTransformationSchema,
    z5.array(NamedTransformationSchema)
  ]).describe(JSON.stringify({
    text: "Named transformations to apply to asset.",
    url: "https://cloudinary.com/documentation/image_transformations#named_transformations"
  })).optional(),
  /**
   * @deprecated use {@link `namedTransformations`} instead
   */
  transformations: z5.union([
    NamedTransformationSchema,
    z5.array(NamedTransformationSchema)
  ]).describe(JSON.stringify({
    text: "Deprecated: use namedTransformations instead",
    url: "https://cloudinary.com/documentation/image_transformations#named_transformations"
  })).optional()
};
var assetTypes4 = ["image", "images", "video", "videos"];
var strict = true;
function plugin4(props21) {
  const { cldAsset, options } = props21;
  const { transformations, namedTransformations } = options;
  if (transformations && process.env.NODE_ENVIRONMENT === "development") {
    console.warn("The transformations prop is deprecated. Please use namedTransformations instead.");
  }
  let _namedTransformations = namedTransformations || transformations || [];
  if (!Array.isArray(_namedTransformations)) {
    _namedTransformations = [_namedTransformations];
  }
  _namedTransformations.forEach((transformation) => {
    cldAsset.addTransformation(`t_${transformation}`);
  });
  return {};
}

// src/plugins/overlays.ts
var overlays_exports = {};
__export(overlays_exports, {
  DEFAULT_TEXT_OPTIONS: () => DEFAULT_TEXT_OPTIONS,
  assetTypes: () => assetTypes5,
  plugin: () => plugin5,
  props: () => props5
});
import { z as z6 } from "zod";
import { encodeBase64, objectHasKey, sortByKey } from "@cloudinary-util/util";
var overlayTextSchema = z6.object({
  alignment: z6.string().optional(),
  antialias: z6.string().optional(),
  border: z6.string().optional(),
  color: z6.string().optional(),
  fontFamily: z6.string().optional(),
  fontSize: z6.number().optional(),
  fontStyle: z6.union([
    z6.string(),
    z6.number()
  ]).optional(),
  fontWeight: z6.string().optional(),
  hinting: z6.union([
    z6.string(),
    z6.number()
  ]).optional(),
  letterSpacing: z6.union([
    z6.string(),
    z6.number()
  ]).optional(),
  lineSpacing: z6.union([
    z6.string(),
    z6.number()
  ]).optional(),
  stroke: z6.string().optional(),
  text: z6.string()
  // Required if using object format
});
var overlayPositionSchema = z6.object({
  angle: angle.schema.optional(),
  gravity: gravity.schema.optional(),
  x: x.schema.optional(),
  y: y.schema.optional()
});
var overlaySchema = z6.object({
  appliedEffects: z6.array(z6.object({})).optional(),
  appliedFlags: flags.schema.optional(),
  effects: z6.array(z6.object({})).optional(),
  crop: crop.schema.optional(),
  flags: flags.schema.optional(),
  height: height.schema.optional(),
  position: overlayPositionSchema.optional(),
  publicId: z6.string().optional(),
  text: z6.union([
    z6.string(),
    overlayTextSchema
  ]).optional(),
  url: z6.string().optional(),
  width: width.schema.optional()
});
var props5 = {
  overlay: overlaySchema.describe(JSON.stringify({
    text: "Image or text layer that is applied on top of the base image.",
    url: "https://cloudinary.com/documentation/transformation_reference#l_layer"
  })).optional(),
  overlays: z6.array(overlaySchema).describe(JSON.stringify({
    text: "Image or text layers that are applied on top of the base image.",
    url: "https://cloudinary.com/documentation/transformation_reference#l_layer"
  })).optional(),
  text: z6.string().describe(JSON.stringify({
    text: "Text to be overlaid on asset.",
    url: "https://cloudinary.com/documentation/image_transformations#transformation_url_structure"
  })).optional()
};
var assetTypes5 = ["image", "images", "video", "videos"];
var DEFAULT_TEXT_OPTIONS = {
  color: "black",
  fontFamily: "Arial",
  fontSize: 200,
  fontWeight: "bold"
};
function plugin5(props21) {
  const { cldAsset, options } = props21;
  const { text: text2, overlays = [] } = options;
  const type = "overlay";
  const typeQualifier = "l";
  if (Array.isArray(overlays)) {
    overlays.forEach(applyOverlay);
  }
  if (typeof text2 === "string") {
    applyOverlay({
      text: Object.assign({}, DEFAULT_TEXT_OPTIONS, {
        text: text2
      })
    });
  } else if (typeof text2 === "object") {
    applyOverlay({
      text: Object.assign({}, DEFAULT_TEXT_OPTIONS, text2)
    });
  }
  function applyOverlay({ publicId, url, position: position2, text: text3, effects: layerEffects = [], appliedEffects = [], flags: layerFlags = [], appliedFlags = [], ...options2 }) {
    const hasPublicId = typeof publicId === "string";
    const hasUrl = typeof url === "string";
    const hasText = typeof text3 === "object" || typeof text3 === "string";
    const hasPosition = typeof position2 === "object";
    if (!hasPublicId && !hasUrl && !hasText) {
      console.warn(`An ${type} is missing Public ID, URL, or Text`);
      return;
    }
    let layerTransformation;
    if (hasText) {
      layerTransformation = `${typeQualifier}_text`;
    } else if (hasPublicId) {
      layerTransformation = `${typeQualifier}_${publicId.replace(/\//g, ":")}`;
    } else if (hasUrl) {
      layerTransformation = `${typeQualifier}_fetch:${encodeBase64(url)}`;
    }
    const primary2 = [];
    const applied = [];
    Object.keys(options2).forEach((key) => {
      if (!objectHasKey(primary, key))
        return;
      const { qualifier, converters } = primary[key];
      const transformation = constructTransformation({
        qualifier,
        value: options2[key],
        converters
      });
      if (transformation) {
        primary2.push(transformation);
      }
    });
    layerEffects.forEach((effect) => {
      Object.keys(effect).forEach((key) => {
        const effectQualifier = primary[key] || effects[key] || position[key];
        if (!effectQualifier)
          return;
        const { qualifier, prefix, converters } = effectQualifier;
        const transformation = constructTransformation({
          qualifier,
          prefix,
          value: effect[key],
          converters
        });
        if (transformation) {
          primary2.push(transformation);
        }
      });
    });
    appliedEffects.forEach((effect) => {
      Object.keys(effect).forEach((key) => {
        const effectQualifier = primary[key] || effects[key] || position[key];
        if (!effectQualifier)
          return;
        const { qualifier, prefix, converters } = effectQualifier;
        const transformation = constructTransformation({
          qualifier,
          prefix,
          value: effect[key],
          converters
        });
        if (transformation) {
          applied.push(transformation);
        }
      });
    });
    const activeLayerFlags = Array.isArray(layerFlags) ? layerFlags : [layerFlags];
    activeLayerFlags.forEach((flag) => {
      const { success } = flagsEnum.safeParse(flag);
      if (!success) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`Invalid flag ${flag}, not applying.`);
        }
        return;
      }
      primary2.push(`fl_${flag}`);
    });
    const activeAppliedFlags = Array.isArray(appliedFlags) ? appliedFlags : [appliedFlags];
    activeAppliedFlags.forEach((flag) => {
      const { success } = flagsEnum.safeParse(flag);
      if (!success) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`Invalid flag ${flag}, not applying.`);
        }
        return;
      }
      applied.push(`fl_${flag}`);
    });
    if (hasText) {
      if (typeof text3 === "string") {
        text3 = {
          ...DEFAULT_TEXT_OPTIONS,
          text: text3
        };
      }
      const textTransformations = [];
      if (typeof text3 === "object") {
        const textOptions = Object.keys(text3).filter((key) => objectHasKey(text, key)).map((key) => {
          const value = text3 && objectHasKey(text3, key) && text3[key];
          return {
            ...text[key],
            key,
            value,
            order: text[key].order || 99
          };
        });
        const sortedTextOptions = sortByKey(textOptions, "order");
        for (const textOption of sortedTextOptions) {
          const { key, value, qualifier, location, converters } = textOption;
          let textValue = value;
          converters?.forEach(({ test, convert }) => {
            if (!test(value))
              return;
            textValue = convert(value);
          });
          if (location === "primary") {
            primary2.push(`${qualifier}_${textValue}`);
          } else if (qualifier === "self") {
            textTransformations.push(key);
          } else if (qualifier) {
            textTransformations.push(`${qualifier}_${textValue}`);
          } else {
            textTransformations.push(textValue);
          }
        }
      }
      const specialCharacters = {
        ".": "%2E",
        ",": "%2C",
        "/": "%2F"
      };
      let layerText = text3?.text || "";
      if (typeof layerText === "string") {
        Object.keys(specialCharacters)?.forEach((character) => {
          layerText = layerText?.replace(character, specialCharacters[character]);
        });
      }
      layerTransformation = `${layerTransformation}:${textTransformations.join("_")}:${layerText}`;
    }
    if (hasPosition) {
      Object.keys(position2).forEach((key) => {
        if (!objectHasKey(position, key) || !objectHasKey(position2, key))
          return;
        const { qualifier, converters } = position[key];
        const transformation = constructTransformation({
          qualifier,
          value: position2[key],
          converters
        });
        if (transformation) {
          applied.push(transformation);
        }
      });
    }
    if (primary2.length > 0) {
      layerTransformation = `${layerTransformation},${primary2.join(",")}`;
    }
    layerTransformation = `${layerTransformation}/fl_layer_apply,fl_no_overflow`;
    if (applied.length > 0) {
      layerTransformation = `${layerTransformation},${applied.join(",")}`;
    }
    cldAsset.addTransformation(layerTransformation);
  }
  return {};
}

// src/plugins/raw-transformations.ts
var raw_transformations_exports = {};
__export(raw_transformations_exports, {
  assetTypes: () => assetTypes6,
  plugin: () => plugin6,
  props: () => props6
});
import { z as z7 } from "zod";
var RawTransformationSchema = z7.string();
var props6 = {
  rawTransformations: z7.union([
    RawTransformationSchema,
    z7.array(RawTransformationSchema)
  ]).describe(JSON.stringify({
    text: "Array of transformation parameters using the Cloudinary URL API to apply to an asset.",
    url: "https://cloudinary.com/documentation/transformation_reference"
  })).optional()
};
var assetTypes6 = ["image", "images", "video", "videos"];
function plugin6(props21) {
  const { cldAsset, options } = props21;
  let { rawTransformations = [] } = options;
  if (!Array.isArray(rawTransformations)) {
    rawTransformations = [rawTransformations];
  }
  rawTransformations.forEach((transformation) => {
    cldAsset.addTransformation(transformation);
  });
  return {};
}

// src/plugins/remove-background.ts
var remove_background_exports = {};
__export(remove_background_exports, {
  assetTypes: () => assetTypes7,
  plugin: () => plugin7,
  props: () => props7
});
import { z as z8 } from "zod";
var props7 = {
  removeBackground: z8.boolean().describe(JSON.stringify({
    text: "Removes the background of an image using the Cloudinary AI Background Removal Add-On (Required).",
    url: "https://cloudinary.com/documentation/cloudinary_ai_background_removal_addon"
  })).optional()
};
var assetTypes7 = ["image", "images"];
function plugin7(props21) {
  const { cldAsset, options } = props21;
  const { removeBackground = false } = options;
  if (removeBackground) {
    cldAsset.effect("e_background_removal");
  }
  return {};
}

// src/plugins/sanitize.ts
var sanitize_exports = {};
__export(sanitize_exports, {
  assetTypes: () => assetTypes8,
  plugin: () => plugin8,
  props: () => props8
});
import { z as z9 } from "zod";
var props8 = {
  sanitize: z9.boolean().describe(JSON.stringify({
    text: "Runs a sanitizer on SVG images.",
    url: "https://cloudinary.com/documentation/transformation_reference#fl_sanitize"
  })).optional()
};
var assetTypes8 = ["image", "images"];
function plugin8(props21) {
  const { cldAsset, options } = props21;
  const { sanitize = true } = options;
  const shouldApplySanitizer = sanitize && (options.format === "svg" || cldAsset.publicID.endsWith(".svg"));
  if (shouldApplySanitizer) {
    cldAsset.effect("fl_sanitize");
  }
  return {};
}

// src/plugins/seo.ts
var seo_exports = {};
__export(seo_exports, {
  assetTypes: () => assetTypes9,
  plugin: () => plugin9,
  props: () => props9
});
import { z as z10 } from "zod";
var props9 = {
  seoSuffix: z10.string().describe(JSON.stringify({
    text: "Configures the URL to include an SEO-friendly suffix in the URL",
    url: "https://cloudinary.com/documentation/advanced_url_delivery_options#seo_friendly_media_asset_urls"
  })).optional()
};
var assetTypes9 = ["image", "images", "video", "videos"];
function plugin9(props21) {
  const { cldAsset, options } = props21;
  const { seoSuffix } = options;
  if (typeof seoSuffix === "string") {
    if (options.deliveryType === "fetch") {
      console.warn("SEO suffix is not supported with a delivery type of fetch");
    } else {
      cldAsset.setSuffix(seoSuffix);
    }
  }
  return {};
}

// src/plugins/underlays.ts
var underlays_exports = {};
__export(underlays_exports, {
  assetTypes: () => assetTypes10,
  plugin: () => plugin10,
  props: () => props10
});
import { z as z11 } from "zod";
import { objectHasKey as objectHasKey2 } from "@cloudinary-util/util";
var underlayPositionSchema = z11.object({
  angle: angle.schema.optional(),
  gravity: gravity.schema.optional(),
  x: x.schema.optional(),
  y: y.schema.optional()
});
var underlaySchema = z11.object({
  appliedEffects: z11.array(z11.object({})).optional(),
  appliedFlags: flags.schema.optional(),
  effects: z11.array(z11.object({})).optional(),
  crop: crop.schema.optional(),
  flags: flags.schema.optional(),
  height: height.schema.optional(),
  position: underlayPositionSchema.optional(),
  publicId: z11.string().optional(),
  type: z11.string().optional(),
  url: z11.string().optional(),
  width: width.schema.optional()
});
var props10 = {
  underlay: z11.string().describe(JSON.stringify({
    text: "Public ID of image that is applied under the base image.",
    url: "https://cloudinary.com/documentation/transformation_reference#l_layer"
  })).optional(),
  underlays: z11.array(underlaySchema).describe(JSON.stringify({
    text: "Image layers that are applied under the base image.",
    url: "https://cloudinary.com/documentation/transformation_reference#l_layer"
  })).optional()
};
var assetTypes10 = ["image", "images", "video", "videos"];
function plugin10(props21) {
  const { cldAsset, options } = props21;
  const { underlay, underlays = [] } = options;
  const typeQualifier = "u";
  if (Array.isArray(underlays)) {
    underlays.forEach(applyUnderlay);
  }
  if (typeof underlay === "string") {
    const underlayOptions = {
      publicId: underlay,
      crop: "fill",
      width: "1.0",
      height: "1.0",
      flags: ["relative"]
    };
    applyUnderlay(underlayOptions);
  }
  function applyUnderlay({ publicId, type, position: position2, effects: layerEffects = [], flags: layerFlags = [], appliedFlags = [], ...options2 }) {
    const hasPublicId = typeof publicId === "string";
    const hasPosition = typeof position2 === "object";
    if (!hasPublicId) {
      console.warn(`An ${type} is missing a Public ID`);
      return;
    }
    let layerTransformation = `${typeQualifier}_${publicId.replace(/\//g, ":")}`;
    const primary2 = [];
    const applied = [];
    Object.keys(options2).forEach((key) => {
      if (!objectHasKey2(primary, key))
        return;
      const { qualifier } = primary[key];
      primary2.push(`${qualifier}_${options2[key]}`);
    });
    layerEffects.forEach((effect) => {
      Object.keys(effect).forEach((key) => {
        if (!objectHasKey2(primary, key))
          return;
        const { qualifier } = primary[key];
        primary2.push(`${qualifier}_${effect[key]}`);
      });
    });
    if (hasPosition) {
      Object.keys(position2).forEach((key) => {
        if (!objectHasKey2(position, key))
          return;
        const { qualifier } = position[key];
        applied.push(`${qualifier}_${position2[key]}`);
      });
    }
    const activeLayerFlags = Array.isArray(layerFlags) ? layerFlags : [layerFlags];
    activeLayerFlags.forEach((flag) => {
      const { success } = flagsEnum.safeParse(flag);
      if (!success) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`Invalid flag ${flag}, not applying.`);
        }
        return;
      }
      primary2.push(`fl_${flag}`);
    });
    const activeAppliedFlags = Array.isArray(appliedFlags) ? appliedFlags : [appliedFlags];
    activeAppliedFlags.forEach((flag) => {
      const { success } = flagsEnum.safeParse(flag);
      if (!success) {
        if (process.env.NODE_ENV === "development") {
          console.warn(`Invalid flag ${flag}, not applying.`);
        }
        return;
      }
      applied.push(`fl_${flag}`);
    });
    layerTransformation = `${layerTransformation},${primary2.join(",")}`;
    layerTransformation = `${layerTransformation}/fl_layer_apply,fl_no_overflow`;
    if (applied.length > 0) {
      layerTransformation = `${layerTransformation},${applied.join(",")}`;
    }
    cldAsset.addTransformation(layerTransformation);
  }
  return {};
}

// src/plugins/version.ts
var version_exports = {};
__export(version_exports, {
  assetTypes: () => assetTypes11,
  plugin: () => plugin11,
  props: () => props11
});
import { z as z12 } from "zod";
var props11 = {
  version: z12.union([
    z12.number(),
    z12.string()
  ]).describe(JSON.stringify({
    text: "Custom version number to apply to asset URL.",
    url: "https://cloudinary.com/documentation/advanced_url_delivery_options#asset_versions"
  })).optional()
};
var assetTypes11 = ["image", "images", "video", "videos"];
function plugin11(props21) {
  const { cldAsset, options } = props21;
  const { version } = options;
  if (typeof version === "string" || typeof version === "number") {
    cldAsset.setVersion(`${version}`.replace("v", ""));
  }
  return {};
}

// src/types/asset.ts
var assetOptionsSchema = z13.object({
  assetType: z13.string().default("image").describe(JSON.stringify({
    text: "The type of asset to deliver.",
    url: "https://cloudinary.com/documentation/image_transformations#transformation_url_structure"
  })).optional(),
  deliveryType: z13.string().default("upload").describe(JSON.stringify({
    text: "Delivery method of the asset.",
    url: "https://cloudinary.com/documentation/image_transformations#delivery_types"
  })).optional(),
  dpr: z13.union([z13.string(), z13.number()]).describe(JSON.stringify({
    text: "Delivery method of the asset.",
    url: "https://cloudinary.com/documentation/image_transformations#delivery_types"
  })).optional(),
  format: z13.string().default("auto").describe(JSON.stringify({
    text: "Converts (if necessary) and delivers an asset in the specified format.",
    url: "https://cloudinary.com/documentation/transformation_reference#f_format"
  })).optional(),
  height: z13.union([z13.string(), z13.number()]).describe(JSON.stringify({
    text: "Height of the given asset."
  })).optional(),
  quality: z13.union([z13.string(), z13.number(), z13.string()]).default("auto").describe(JSON.stringify({
    text: "Quality of the delivered asset",
    url: "https://cloudinary.com/documentation/transformation_reference#q_quality"
  })).optional(),
  src: z13.string().describe(JSON.stringify({
    text: "Cloudinary Public ID or versioned Cloudinary URL (/v1234/)"
  })),
  strictTransformations: z13.boolean().describe(JSON.stringify({
    text: "Gives you the ability to have more control over what transformations are permitted to be used from your Cloudinary account.",
    url: "https://cloudinary.com/documentation/control_access_to_media#strict_transformations"
  })).optional(),
  width: z13.union([z13.string(), z13.number()]).describe(JSON.stringify({
    text: "Width of the given asset."
  })).optional(),
  // Spreading plugins instead of extend or merge to avoid excessive schema warning
  // https://github.com/microsoft/TypeScript/issues/34933#issuecomment-1772787785
  ...props,
  ...props2,
  ...props3,
  ...props4,
  ...props5,
  ...props6,
  ...props7,
  ...props8,
  ...props9,
  ...props10,
  ...props11
});

// src/types/image.ts
import { z as z22 } from "zod";

// src/plugins/default-image.ts
var default_image_exports = {};
__export(default_image_exports, {
  assetTypes: () => assetTypes12,
  plugin: () => plugin12,
  props: () => props12
});
import { z as z14 } from "zod";
import { getFormat } from "@cloudinary-util/util";
var props12 = {
  defaultImage: z14.string().describe(JSON.stringify({
    text: "Configures the default image to use in case the given public ID is not available. Must include file extension.",
    url: "https://cloudinary.com/documentation/transformation_reference#d_default_image"
  })).optional()
};
var assetTypes12 = ["image", "images"];
function plugin12(props21) {
  const { cldAsset, options } = props21;
  const { defaultImage } = options;
  if (typeof defaultImage === "string") {
    if (!getFormat(defaultImage)) {
      console.warn(`The defaultImage prop may be missing a format and must include it along with the public ID. (Ex: myimage.jpg)`);
    }
    const defaultImageId = defaultImage.replace(/\//g, ":");
    cldAsset.addTransformation(`d_${defaultImageId}`);
  }
  return {};
}

// src/plugins/fill-background.ts
var fill_background_exports = {};
__export(fill_background_exports, {
  assetTypes: () => assetTypes13,
  plugin: () => plugin13,
  props: () => props13
});
import { z as z15 } from "zod";
var props13 = {
  fillBackground: z15.union([
    z15.boolean(),
    z15.object({
      crop: crop.schema.optional(),
      gravity: gravity.schema.optional(),
      prompt: z15.string().optional()
    })
  ]).describe(JSON.stringify({
    text: "Uses Generative Fill to extended padded image with AI",
    url: "https://cloudinary.com/documentation/transformation_reference#b_gen_fill"
  })).optional()
};
var assetTypes13 = ["image", "images"];
var defaultCrop = "pad";
function plugin13(props21) {
  const { cldAsset, options } = props21;
  const { fillBackground } = options;
  if (typeof fillBackground === "undefined")
    return;
  const width2 = normalizeNumberParameter(options.width);
  const height2 = normalizeNumberParameter(options.height);
  const hasDefinedDimensions = typeof height2 === "number" && typeof width2 === "number";
  let aspectRatio2 = options.aspectRatio;
  if (!aspectRatio2 && hasDefinedDimensions) {
    aspectRatio2 = `${width2}:${height2}`;
  }
  if (!aspectRatio2) {
    if (process.env.NODE_ENV === "development") {
      console.warn(`Could not determine aspect ratio based on available options to use fillBackground. Please specify width and height or an aspect ratio.`);
    }
    return;
  }
  if (fillBackground === true) {
    const properties = [
      "b_gen_fill",
      `ar_${aspectRatio2}`,
      `c_${defaultCrop}`
    ];
    cldAsset.addTransformation(properties.join(","));
  } else if (typeof fillBackground === "object") {
    const { crop: crop2 = defaultCrop, gravity: gravity2, prompt } = fillBackground;
    const properties = [
      `ar_${aspectRatio2}`,
      `c_${crop2}`
    ];
    if (typeof prompt === "string") {
      properties.unshift(`b_gen_fill:${prompt}`);
    } else {
      properties.unshift(`b_gen_fill`);
    }
    if (typeof gravity2 === "string") {
      properties.push(`g_${gravity2}`);
    }
    cldAsset.addTransformation(properties.join(","));
  }
  return {};
}

// src/plugins/recolor.ts
var recolor_exports = {};
__export(recolor_exports, {
  assetTypes: () => assetTypes14,
  plugin: () => plugin14,
  props: () => props14
});
import { z as z16 } from "zod";
var imageOptionsRecolorPromptSchema = z16.union([
  z16.string(),
  z16.array(z16.string())
]);
var imageOptionsRecolorSchema = z16.object({
  prompt: imageOptionsRecolorPromptSchema.optional(),
  to: z16.string().optional(),
  multiple: z16.boolean().optional()
});
var props14 = {
  recolor: z16.union([
    imageOptionsRecolorPromptSchema,
    imageOptionsRecolorSchema
  ]).describe(JSON.stringify({
    text: "Uses generative AI to recolor parts of your image, maintaining the relative shading.",
    url: "https://cloudinary.com/documentation/transformation_reference#e_gen_recolor"
  })).optional()
};
var assetTypes14 = ["image", "images"];
function plugin14(props21) {
  const { cldAsset, options } = props21;
  const { recolor } = options;
  const recolorOptions = {
    prompt: void 0,
    "to-color": void 0,
    multiple: void 0
  };
  if (Array.isArray(recolor)) {
    if (Array.isArray(recolor[0])) {
      recolorOptions.prompt = promptArrayToString(recolor[0]);
    } else {
      recolorOptions.prompt = recolor[0];
    }
    if (typeof recolor[1] === "string") {
      recolorOptions["to-color"] = recolor[1];
    }
  } else if (typeof recolor === "object") {
    if (typeof recolor.prompt === "string") {
      recolorOptions.prompt = recolor.prompt;
    } else if (Array.isArray(recolor.prompt)) {
      recolorOptions.prompt = promptArrayToString(recolor.prompt);
    }
    if (typeof recolor.to === "string") {
      recolorOptions["to-color"] = recolor.to;
    }
    if (recolor.multiple === true) {
      recolorOptions.multiple = `true`;
    }
  }
  const transformation = Object.entries(recolorOptions).filter(([, value]) => !!value).map(([key, value]) => `${key}_${value}`).join(";");
  if (transformation) {
    cldAsset.addTransformation(`e_gen_recolor:${transformation}`);
  }
  return {};
}

// src/plugins/remove.ts
var remove_exports = {};
__export(remove_exports, {
  assetTypes: () => assetTypes15,
  plugin: () => plugin15,
  props: () => props15
});
import { z as z17 } from "zod";
var imageOptionsRemovePromptSchema = z17.union([
  z17.string(),
  z17.array(z17.string())
]);
var imageOptionsRemoveSchema = z17.object({
  prompt: imageOptionsRemovePromptSchema.optional(),
  region: z17.union([
    z17.array(z17.number()),
    z17.array(z17.array(z17.number()))
  ]).optional(),
  multiple: z17.boolean().optional(),
  removeShadow: z17.boolean().optional()
});
var props15 = {
  remove: z17.union([
    imageOptionsRemovePromptSchema,
    imageOptionsRemoveSchema
  ]).describe(JSON.stringify({
    text: "Applies zooming and/or panning to an image, resulting in a video or animated image.",
    url: "https://cloudinary.com/documentation/transformation_reference#e_zoompan"
  })).optional()
};
var assetTypes15 = ["image", "images"];
function plugin15(props21) {
  const { cldAsset, options } = props21;
  const { remove } = options;
  const removeOptions = {
    prompt: void 0,
    region: void 0,
    multiple: void 0,
    "remove-shadow": void 0
  };
  if (typeof remove === "string") {
    removeOptions.prompt = remove;
  } else if (Array.isArray(remove)) {
    removeOptions.prompt = promptArrayToString(remove);
  } else if (typeof remove === "object") {
    const hasPrompt = typeof remove.prompt === "string" || Array.isArray(remove.prompt);
    const hasRegion = Array.isArray(remove.region);
    if (hasPrompt && hasRegion) {
      throw new Error("Invalid remove options: you can not have both a prompt and a region. More info: https://cloudinary.com/documentation/transformation_reference#e_gen_remove");
    }
    if (typeof remove.prompt === "string") {
      removeOptions.prompt = remove.prompt;
    } else if (Array.isArray(remove.prompt)) {
      removeOptions.prompt = promptArrayToString(remove.prompt);
    }
    if (Array.isArray(remove.region)) {
      removeOptions.region = regionArrayToString(remove.region);
    }
    if (remove.multiple === true) {
      removeOptions.multiple = `true`;
    }
    if (remove.removeShadow === true) {
      removeOptions["remove-shadow"] = `true`;
    }
  }
  const transformation = Object.entries(removeOptions).filter(([, value]) => !!value).map(([key, value]) => `${key}_${value}`).join(";");
  if (transformation) {
    cldAsset.addTransformation(`e_gen_remove:${transformation}`);
  }
  return {};
}
function regionArrayToString(regionArray) {
  const indexes = {
    0: "x",
    1: "y",
    2: "w",
    3: "h"
  };
  const regionString = regionArray.map((region, index) => {
    if (Array.isArray(region)) {
      return regionArrayToString(region);
    }
    const key = indexes[index];
    return `${key}_${region}`;
  }).join(";");
  return `(${regionString})`;
}

// src/plugins/enhance.ts
var enhance_exports = {};
__export(enhance_exports, {
  assetTypes: () => assetTypes16,
  plugin: () => plugin16,
  props: () => props16
});
import { z as z18 } from "zod";
var props16 = {
  enhance: z18.boolean().describe(JSON.stringify({
    text: "Uses AI to analyze an image and make adjustments to enhance the appeal of the image.",
    url: "https://cloudinary.com/documentation/transformation_reference#e_enhance"
  })).optional()
};
var assetTypes16 = ["image", "images"];
function plugin16(props21) {
  const { cldAsset, options } = props21;
  const { enhance = false } = options;
  if (enhance) {
    cldAsset.effect("e_enhance");
  }
  return {};
}

// src/plugins/restore.ts
var restore_exports = {};
__export(restore_exports, {
  assetTypes: () => assetTypes17,
  plugin: () => plugin17,
  props: () => props17
});
import { z as z19 } from "zod";
var props17 = {
  restore: z19.boolean().describe(JSON.stringify({
    text: "Uses generative AI to restore details in poor quality images or images that may have become degraded through repeated processing and compression.",
    url: "https://cloudinary.com/documentation/transformation_reference#e_gen_restore"
  })).optional()
};
var assetTypes17 = ["image", "images"];
function plugin17(props21) {
  const { cldAsset, options } = props21;
  const { restore = false } = options;
  if (restore) {
    cldAsset.effect("e_gen_restore");
  }
  return {};
}

// src/plugins/replace.ts
var replace_exports = {};
__export(replace_exports, {
  assetTypes: () => assetTypes18,
  plugin: () => plugin18,
  props: () => props18
});
import { z as z20 } from "zod";
var props18 = {
  replace: z20.union([
    z20.array(z20.string()),
    z20.array(z20.boolean()),
    z20.object({
      to: z20.string(),
      from: z20.string(),
      preserveGeometry: z20.boolean().optional()
    })
  ]).describe(JSON.stringify({
    text: "Uses generative AI to replace parts of your image with something else.",
    url: "https://cloudinary.com/documentation/transformation_reference#e_gen_replace"
  })).optional()
};
var assetTypes18 = ["image", "images"];
function plugin18(props21) {
  const { cldAsset, options } = props21;
  const { replace = null } = options;
  if (replace) {
    let from, to, preserveGeometry = false;
    if (Array.isArray(replace)) {
      from = replace[0];
      to = replace[1];
      preserveGeometry = replace[2] || false;
    } else {
      from = replace.from;
      to = replace.to;
      preserveGeometry = replace.preserveGeometry || false;
    }
    const properties = [`e_gen_replace:from_${from}`, `to_${to}`];
    if (preserveGeometry) {
      properties.push(`preserve-geometry_${preserveGeometry}`);
    }
    cldAsset.effect(properties.join(";"));
  }
  return {};
}

// src/plugins/zoompan.ts
var zoompan_exports = {};
__export(zoompan_exports, {
  assetTypes: () => assetTypes19,
  plugin: () => plugin19,
  props: () => props19
});
import { z as z21 } from "zod";
var props19 = {
  zoompan: z21.union([
    z21.string(),
    z21.boolean(),
    z21.object({
      loop: effects.loop.schema.optional(),
      options: z21.string()
    })
  ]).describe(JSON.stringify({
    text: "Applies zooming and/or panning to an image, resulting in a video or animated image.",
    url: "https://cloudinary.com/documentation/transformation_reference#e_zoompan"
  })).optional()
};
var assetTypes19 = ["image", "images"];
function plugin19(props21) {
  const { cldAsset, options } = props21;
  const { zoompan = false } = options;
  const overrides = {
    format: void 0
  };
  if (zoompan === true) {
    cldAsset.effect("e_zoompan");
  } else if (typeof zoompan === "string") {
    if (zoompan === "loop") {
      cldAsset.effect("e_zoompan");
      cldAsset.effect("e_loop");
    } else {
      cldAsset.effect(`e_zoompan:${zoompan}`);
    }
  } else if (typeof zoompan === "object") {
    let zoompanEffect = "e_zoompan";
    if (typeof zoompan.options === "string") {
      zoompanEffect = `${zoompanEffect}:${zoompan.options}`;
    }
    cldAsset.effect(zoompanEffect);
    let loopEffect;
    if (zoompan.loop === true) {
      loopEffect = "e_loop";
    } else if (typeof zoompan.loop === "string" || typeof zoompan.loop === "number") {
      loopEffect = `e_loop:${zoompan.loop}`;
    }
    if (loopEffect) {
      cldAsset.effect(loopEffect);
    }
  }
  if (zoompan !== false) {
    overrides.format = "auto:animated";
  }
  return {
    options: overrides
  };
}

// src/types/image.ts
var imageOptionsSchema = assetOptionsSchema.merge(z22.object({
  // Spreading plugins instead of extend or merge to avoid excessive schema warning
  // https://github.com/microsoft/TypeScript/issues/34933#issuecomment-1772787785
  ...props12,
  ...props16,
  ...props13,
  ...props14,
  ...props15,
  ...props18,
  ...props17,
  ...props19
}));

// src/types/video.ts
import { z as z24 } from "zod";

// src/plugins/abr.ts
var abr_exports = {};
__export(abr_exports, {
  assetTypes: () => assetTypes20,
  plugin: () => plugin20,
  props: () => props20
});
import { z as z23 } from "zod";
var props20 = {
  streamingProfile: z23.string().describe(JSON.stringify({
    text: "The streaming profile to apply when delivering a video using adaptive bitrate streaming.",
    url: "https://cloudinary.com/documentation/transformation_reference#sp_streaming_profile"
  })).optional()
};
var assetTypes20 = ["video", "videos"];
function plugin20(props21) {
  const { cldAsset, options } = props21;
  const { streamingProfile } = options;
  if (typeof streamingProfile === "string") {
    cldAsset.addTransformation(`sp_${streamingProfile}`);
  }
  return {};
}

// src/types/video.ts
var videoOptionsSchema = assetOptionsSchema.merge(z24.object({
  // Spreading plugins instead of extend or merge to avoid excessive schema warning
  // https://github.com/microsoft/TypeScript/issues/34933#issuecomment-1772787785
  ...props20
}));

// src/lib/cloudinary.ts
import { z as z27 } from "zod";
import { Cloudinary } from "@cloudinary/url-gen";
import { parseUrl, objectHasKey as objectHasKey3 } from "@cloudinary-util/util";

// src/types/analytics.ts
import { z as z25 } from "zod";
var analyticsOptionsSchema = z25.any();

// src/types/config.ts
import { z as z26 } from "zod";
var configOptionsSchema = z26.any();

// src/lib/cloudinary.ts
var transformationPlugins = [
  // Some features *must* be the first transformation applied
  // thus their plugins *must* come first in the chain
  enhance_exports,
  recolor_exports,
  remove_background_exports,
  remove_exports,
  replace_exports,
  restore_exports,
  // Cropping needs to be before any other general transformations
  // as it provides the option of 2-step resizing where someone
  // can resize the "base" canvas as well as the final resize
  // mechanism commonly used for responsive resizing
  cropping_exports,
  // Raw transformations should always come before
  // other arguments to avoid conflicting with
  // added options via the component
  raw_transformations_exports,
  abr_exports,
  default_image_exports,
  effects_exports,
  fill_background_exports,
  flags_exports,
  overlays_exports,
  sanitize_exports,
  named_transformations_exports,
  seo_exports,
  underlays_exports,
  version_exports,
  zoompan_exports
];
var constructUrlPropsSchema = z27.object({
  analytics: z27.union([
    analyticsOptionsSchema,
    z27.boolean()
  ]).describe(JSON.stringify({
    text: "Tech, dependency, and feature identifiers for tracking SDK usage related to Cloudinary.",
    path: "/url-loader/analyticsoptions"
  })).optional(),
  config: configOptionsSchema.describe(JSON.stringify({
    text: "Configuration parameters for environment and Cloudinary account.",
    url: "https://cloudinary.com/documentation/cloudinary_sdks#configuration_parameters",
    path: "/url-loader/analyticsoptions"
  })).optional(),
  options: z27.union([
    assetOptionsSchema,
    imageOptionsSchema,
    videoOptionsSchema
  ]).describe(JSON.stringify({
    text: "Asset options (Image or Video) that define delivery URL including public ID and transformations.",
    path: "/url-loader/assetoptions"
  }))
});
function constructCloudinaryUrl({ options, config = {}, analytics }) {
  if (analytics === false) {
    if (typeof config?.url === "undefined") {
      config.url = {};
    }
    config.url.analytics = false;
  }
  const cld = new Cloudinary(config);
  if (typeof options?.src !== "string") {
    throw Error(`Failed to construct Cloudinary URL: Missing source (src) in options.`);
  }
  if (!options?.assetType) {
    options.assetType = "image";
  }
  const propsCheck = [];
  transformationPlugins.forEach(({ props: props21 }) => {
    const pluginProps = Object.keys(props21);
    pluginProps.forEach((prop) => {
      if (propsCheck.includes(prop)) {
        throw new Error(`Option ${prop} already exists!`);
      }
      propsCheck.push(prop);
    });
  });
  const parsedOptions = {};
  let publicId;
  if (typeof options.src === "string" && /^https?:\/\//.test(options.src)) {
    try {
      const parts = parseUrl(options.src);
      publicId = parts?.publicId;
      parsedOptions.seoSuffix = parts?.seoSuffix;
      parsedOptions.version = parts?.version;
    } catch (e) {
    }
  }
  if (!publicId) {
    publicId = options.src;
  }
  Object.keys(parsedOptions).forEach((key) => {
    if (objectHasKey3(options, key))
      return;
    options[key] = parsedOptions[key];
  });
  let cldAsset = void 0;
  if (["image", "images"].includes(options.assetType)) {
    cldAsset = cld.image(publicId);
  } else if (["video", "videos"].includes(options.assetType)) {
    cldAsset = cld.video(publicId);
  }
  if (typeof cldAsset === "undefined") {
    throw new Error("Invalid asset type.");
  }
  const pluginEffects = {};
  transformationPlugins.forEach(({ plugin: plugin21, assetTypes: assetTypes21, props: props21, strict: strict2 }) => {
    const supportedAssetType = typeof options?.assetType !== "undefined" && assetTypes21.includes(options?.assetType);
    const pluginProps = Object.keys(props21);
    const optionsKeys = Object.keys(options);
    const attemptedUse = pluginProps.map((prop) => optionsKeys.includes(prop)).filter((isUsed) => !!isUsed).length > 0;
    if (!supportedAssetType) {
      if (attemptedUse) {
        console.warn(`One of the following props [${pluginProps.join(", ")}] was used with an unsupported asset type [${options?.assetType}]`);
      }
      return;
    }
    if (options.strictTransformations && !strict2) {
      if (attemptedUse) {
        console.warn(`One of the following props [${pluginProps.join(", ")}] was used that is not supported with Strict Transformations.`);
      }
      return;
    }
    const results = plugin21({
      cldAsset,
      options
    });
    const { options: pluginOptions } = results || { options: void 0 };
    Object.assign(pluginEffects, pluginOptions);
  });
  if (typeof pluginEffects.resize === "string") {
    cldAsset.addTransformation(pluginEffects.resize);
  }
  cldAsset.setDeliveryType(options?.deliveryType || "upload");
  if (!options.strictTransformations) {
    if (options?.dpr) {
      let dpr = options.dpr;
      if (typeof dpr === "number") {
        dpr = dpr.toFixed(1);
      }
      cldAsset.addTransformation(`dpr_${dpr}`);
    }
    const defaultFormat = options?.format === "default";
    const rawContainsFormat = searchAssetRawTransformations("f_", cldAsset, { matchType: "startsWith" });
    const rawContainsFormatAndExplicit = rawContainsFormat && typeof options?.format !== "undefined";
    if (pluginEffects?.format || !defaultFormat && (!rawContainsFormat || rawContainsFormatAndExplicit)) {
      cldAsset.format(options?.format || pluginEffects?.format || "auto");
    }
    const defaultQuality = options?.quality === "default";
    const rawContainsQuality = searchAssetRawTransformations("q_", cldAsset, { matchType: "startsWith" });
    const rawContainsQualityAndExplicit = rawContainsQuality && typeof options?.quality !== "undefined";
    if (!defaultQuality && (!rawContainsQuality || rawContainsQualityAndExplicit)) {
      cldAsset.quality(options?.quality || "auto");
    }
  }
  return cldAsset.toURL({
    trackedAnalytics: analytics
  });
}
function searchAssetRawTransformations(query, asset, options) {
  if (typeof asset.transformation === "undefined")
    return;
  const { matchType = "includes" } = options || {};
  const transformations = asset.transformation.actions.flatMap((transformation) => {
    return transformation.toString().split("/").flatMap((seg) => seg.split(","));
  });
  const matches = transformations.filter((transformation) => {
    if (matchType === "startsWith") {
      return transformation.startsWith(query);
    } else {
      return transformation.includes(query);
    }
  });
  return matches.length > 0;
}

export {
  primary,
  position,
  text,
  effects,
  assetOptionsSchema,
  imageOptionsSchema,
  videoOptionsSchema,
  transformationPlugins,
  constructUrlPropsSchema,
  constructCloudinaryUrl
};
